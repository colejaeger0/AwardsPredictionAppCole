## This "input" configures a global authorization rule to enable public access to
## all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
# input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

enum UserRole {
  ADMIN
  TESTER
  USER
}

enum AwardsBody {
  ACADEMY_AWARDS
  GOLDEN_GLOBES
  CRITICS_CHOICE
  BAFTA
  HCA
  PGA
  SAG
  DGA
  WGA
  ADG
  MAKEUP_GUILD
  CDG
  ASC
  MPSE
}

enum PredictionType {
    WIN
    NOMINATION
}

enum ContenderVisibility {
    HIDDEN
    VISIBLE
}

enum CategoryIsShortlisted {
    TRUE
    FALSE
}

enum ContenderAccolade {
    WINNER
    NOMINEE
    SHORTLISTED
}

enum EventStatus {
    NOMS_STAGING # before nominations go public
    NOMS_LIVE # when everyone can predict nominations
    WINS_STAGING # when nominations are being announced + prepared
    WINS_LIVE # when everyone can predict wins
    ARCHIVED # when winners have been announced and such
}

enum CategoryType {
    FILM
    PERFORMANCE
    SONG
}

enum CategoryName {
    PICTURE
    DIRECTOR
    ACTOR
    ACTRESS
    SUPPORTING_ACTOR
    SUPPORTING_ACTRESS
    ORIGINAL_SCREENPLAY
    ADAPTED_SCREENPLAY
    SCREENPLAY
    INTERNATIONAL
    ANIMATED
    DOCUMENTARY
    EDITING
    CINEMATOGRAPHY
    PRODUCTION_DESIGN
    COSTUMES
    MAKEUP
    VISUAL_EFFECTS
    SOUND
    SCORE
    SONG
    SHORT_ANIMATED
    SHORT_DOCUMENTARY
    SHORT_LIVE_ACTION
    ENSEMBLE
    COMEDY_PICTURE
    COMEDY_ACTOR
    COMEDY_ACTRESS
    ACTION_PICTURE
    YOUNG_ACTOR
    RISING_STAR
    DEBUT
    FIRST_SCREENPLAY
    BRITISH_PICTURE
    ANIMATED_PERFORMANCE
    BLOCKBUSTER
    ACTING_ACHIEVEMENT
    FEMALE_DIRECTOR
    MALE_DIRECTOR
    INDIE_PICTURE
    BREAKTHROUGH
}

type User @model @searchable @auth(rules: [{allow: public}]) {
    id: ID! @primaryKey
    email: String!
    username: String
    name: String
    bio: String
    image: String
    role: UserRole! @default(value: "USER")
    oauthId: String
    predictionSets: [PredictionSet] 
        @hasMany(indexName: "predictionSetsbyUserIdAndCreatedAt" fields: ["id"]) # get recent predictions from user
    historyPredictionSets: [HistoryPredictionSet] 
        @hasMany(indexName: "historyPredictionSetsbyUserIdAndCreatedAt" fields: ["id"]) # 
    followers: [Relationship] 
        @hasMany(indexName: "followersByUser", fields: ["id"])
    following: [Relationship] 
        @hasMany(indexName: "followingByUser", fields: ["id"])
}

type Relationship @model @searchable @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    followedUserId: ID! 
        @index(name: "followersByUser", queryField: "relationshipByFollowedUserId")
    followedUser: User! @hasOne(fields: ["followedUserId"])
    followingUserId: ID! 
        @index(name: "followingByUser", queryField: "relationshipByFollowingUserId")
    followingUser: User! @hasOne(fields: ["followingUserId"])
}

type Event @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    categories: [Category] @hasMany(indexName: "byEvent", fields: ["id"])
    awardsBody: AwardsBody!
    year: Int!
    nominationDateTime: AWSDateTime # nullable. admin sets this
    winDateTime: AWSDateTime # nullable. admin sets this
    status: EventStatus @default(value: "NOMS_STAGING")
    predictionSets: [PredictionSet]
        @hasMany(indexName: "predictionSetsByUserIdAndEventId", fields: ["id"]) # get a user's predictions for an event
    historyPredictions: [HistoryPredictionSet] 
        @hasMany(indexName: "historyPredictionSetsbyUserIdAndEventIdAndCreatedAt", fields: ["id"]) # get a user's predictions for an event at x date
    liveAt: AWSDateTime
}

type Category @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    eventId: ID! 
        @index(name: "byEvent", queryField: "categoryByEvent")
    event: Event! @belongsTo(fields: ["eventId"])
    name: CategoryName!
    type: CategoryType! @default(value: "FILM")
    isShortlisted: CategoryIsShortlisted @default(value: "FALSE")
    predictionSets: [PredictionSet] 
        @hasMany(indexName: "predictionSetsByUserIdAndCategoryId", fields: ["id"]) # get a user's predictions for a category
    historyPredictions: [HistoryPredictionSet] 
        @hasMany(indexName: "historyPredictionSetsByUserIdAndCategoryIdAndCreatedAt", fields: ["id"]) # get a user's predictions for a category at x date
}

# Belongs to a particular category
type Contender @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    eventId: ID!
    event: Event! @hasOne(fields: ["eventId"])
    movieId: ID! 
        @index(name: "byMovie", queryField: "contenderByMovie")
    movie: Movie! @belongsTo(fields: ["movieId"]) # lets it be bi-directional so we can see Contenders from Movie
    personId: ID
    person: Person @hasOne(fields: ["personId"]) # optional - only applies to acting categories
    songId: ID
    song: Song @hasOne(fields: ["songId"]) # optional - only applies to the song category
    visibility: ContenderVisibility
    accolade: ContenderAccolade # nullable
}

type Movie @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    contenders: [Contender] 
        @hasMany(indexName: "byMovie", fields: ["id"])
    tmdbId: Int! # unique value
    studio: String # distribution studio
}

type Person @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    tmdbId: Int! # unique value
}
  
type Song @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    movieId: ID!
    movie: Movie! @hasOne(fields: ["movieId"])
    title: String!
    artist: String!
}

# PREDICTIONS:

# CURRENT PERSONAL
type PredictionSet @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    userId: ID! 
        @index(name: "predictionSetsByUserIdAndEventId", sortKeyFields: ["eventId"], queryField: "predictionSetByUserIdAndEventId") # used for request on all user's predictions in given event
        @index(name: "predictionSetsByUserIdAndCategoryId", sortKeyFields: ["categoryId"], queryField: "predictionSetByUserIdAndCategoryId") # used for request on user's predictions in given category
        @index(name: "predictionSetsbyUserIdAndCreatedAt", sortKeyFields: ["createdAt"], queryField: "predictionSetByUserIdAndCreatedAt") # return a user's predictions by most recent (say, last ten predictions updated)
    user: User! @hasOne(fields: ["userId"])
    eventId: ID! 
        @index(queryField: "predictionSetByEventId") # used for compiling community predictions
    event: Event! @hasOne(fields: ["eventId"])
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    predictions: [Prediction] 
        @hasMany(indexName: "predictionByPredictionSetId", fields: ["id"])
    type: PredictionType @default(value: "NOMINATION")
    comment: String
    createdAt: AWSDateTime!
}
type Prediction @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    predictionSetId: ID! 
        @index(name: "predictionByPredictionSetId", queryField: "predictionByPredictionSetId")
    contenderId: ID!
    contender: Contender! @hasOne(fields: ["contenderId"])
    ranking: Int!
}

# HISTORY PERSONAL
type HistoryPredictionSet @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    userId: ID! 
        @index(name: "historyPredictionSetsbyUserIdAndCreatedAt", sortKeyFields: ["createdAt"], queryField: "historyPredictionSetByUserIdAndCreatedAt")
        @index(name: "historyPredictionSetsbyUserIdAndEventIdAndCreatedAt", sortKeyFields: ["eventId", "createdAt"], queryField: "historyPredictionSetByUserIdAndEventIdAndCreatedAt")
        @index(name: "historyPredictionSetsByUserIdAndCategoryIdAndCreatedAt", sortKeyFields: ["categoryId", "createdAt"], queryField: "historyPredictionSetByUserIdAndCategoryIdAndCreatedAt")
    user: User! @hasOne(fields: ["userId"])
    eventId: ID! # for indexing, see historyPredictionSetsbyUserIdAndEventIdAndCreatedAt
    event: Event! @hasOne(fields: ["eventId"])
    categoryId: ID! 
        @index(queryField: "historyPredictionSetByCategoryId")
    category: Category! @hasOne(fields: ["categoryId"])
    predictions: [HistoryPrediction] 
        @hasMany(indexName: "byHistoryPredictionSet", fields: ["id"])
    type: PredictionType @default(value: "NOMINATION")
    comment: String
    createdAt: AWSDateTime!
}
type HistoryPrediction @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    historyPredictionSetId: ID! 
        @index(name: "byHistoryPredictionSet", queryField: "historyPredictionByHistoryPredictionSetId")
    contenderId: ID!
    contender: Contender! @hasOne(fields: ["contenderId"])
    categoryId: ID! 
        @index(queryField: "historyPredictionByCategoryId") # for getting the category history chart
    category: Category! @hasOne(fields: ["categoryId"])
    ranking: Int!
}

# CURRENT COMMUINTY
type CommunityPredictionSet @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    eventId: ID! 
        @index(queryField: "communityPredictionSetByEventId")
    event: Event! @hasOne(fields: ["eventId"])
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    predictions: [CommunityPrediction] 
        @hasMany(indexName: "byCommunityPredictionSet", fields: ["id"])
    type: PredictionType @default(value: "NOMINATION")
}
type CommunityPrediction @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    communityPredictionSetId: ID! 
        @index(name: "byCommunityPredictionSet", queryField: "communityPredictionByCommunityPredictionSetId")
    contenderId: ID!
    contender: Contender! 
        @hasOne(fields: ["contenderId"])
    ranking: Int!
    indexedRankings: String # JSON stringified array of rankings (ts: { [place: number]: [numUsersPredicting: number]})
}

# HISTORY COMMUINTY
type CommunityHistoryPredictionSet @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    eventId: ID! 
        @index(sortKeyFields: ["createdAt"], queryField: "communityHistoryPredictionSetsByEventIdAndCreatedAt")
    event: Event! @hasOne(fields: ["eventId"])
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    predictions: [CommunityHistoryPrediction] 
        @hasMany(indexName: "byCommunityHistoryPredictionSet", fields: ["id"])
    type: PredictionType @default(value: "NOMINATION")
    createdAt: AWSDateTime!
}
type CommunityHistoryPrediction @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    communityHistoryPredictionSetId: ID! 
        @index(name: "byCommunityHistoryPredictionSet", queryField: "communityHistoryPredictionByCommunityHistoryPredictionSetId")
    contenderId: ID!
    contender: Contender! @hasOne(fields: ["contenderId"])
    categoryId: ID! 
        @index(queryField: "communityHistoryPredictionByCategoryId") # for getting the category history chart
    category: Category! @hasOne(fields: ["categoryId"])
    ranking: Int!
    indexedRankings: String # JSON stringified array of rankings (ts: { [place: number]: [numUsersPredicting: number]})
}

# CONNECT LAMBDA FUNCTIONS (Configures function for AppSync)
# https://docs.amplify.aws/cli/graphql/custom-business-logic/#how-it-works
type Mutation {
  updateCommunityPredictions(msg: String): String @function(name: "updateCommunityPredictions-${env}")
  updateCommunityHistory(msg: String): String @function(name: "updateCommunityHistory-${env}")
  updatePersonalHistory(msg: String): String @function(name: "updatePersonalHistory-${env}")
}