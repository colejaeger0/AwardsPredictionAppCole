## This "input" configures a global authorization rule to enable public access to
## all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
# input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

enum UserRole {
  ADMIN
  USER
}

enum AwardsBody {
  ACADEMY_AWARDS
  GOLDEN_GLOBES
  CRITICS_CHOICE
  BAFTA
  HCA
  PGA
  SAG
  DGA
  WGA
  ADG
  MAKEUP_GUILD
  CDG
  ASC
  MPSE
}

enum PredictionType {
    WIN
    NOMINATION
}

enum ContenderVisibility {
    HIDDEN
    VISIBLE
}

enum CategoryIsShortlisted {
    TRUE
    FALSE
}

enum ContenderAccolade {
    WINNER
    NOMINEE
    SHORTLISTED
}

enum EventStatus {
    NOMS_STAGING # before nominations go public
    NOMS_LIVE # when everyone can predict nominations
    WINS_STAGING # when nominations are being announced + prepared
    WINS_LIVE # when everyone can predict wins
    ARCHIVED # when winners have been announced and such
}

enum CategoryType {
    FILM
    PERFORMANCE
    SONG
}

enum CategoryName {
    PICTURE
    DIRECTOR
    ACTOR
    ACTRESS
    SUPPORTING_ACTOR
    SUPPORTING_ACTRESS
    ORIGINAL_SCREENPLAY
    ADAPTED_SCREENPLAY
    SCREENPLAY
    INTERNATIONAL
    ANIMATED
    DOCUMENTARY
    EDITING
    CINEMATOGRAPHY
    PRODUCTION_DESIGN
    COSTUMES
    MAKEUP
    VISUAL_EFFECTS
    SOUND
    SCORE
    SONG
    SHORT_ANIMATED
    SHORT_DOCUMENTARY
    SHORT_LIVE_ACTION
    ENSEMBLE
    COMEDY_PICTURE
    COMEDY_ACTOR
    COMEDY_ACTRESS
    ACTION_PICTURE
    YOUNG_ACTOR
    RISING_STAR
    DEBUT
    FIRST_SCREENPLAY
    BRITISH_PICTURE
    ANIMATED_PERFORMANCE
    BLOCKBUSTER
    ACTING_ACHIEVEMENT
    FEMALE_DIRECTOR
    MALE_DIRECTOR
    INDIE_PICTURE
    BREAKTHROUGH
}

type User @model @auth(rules: [{allow: public}]) {
    id: ID! @primaryKey
    email: String!
    username: String
    name: String
    bio: String
    image: String
    role: UserRole! @default(value: "USER")
    # ON FRONTEND: perform this query but don't include nested "predictions"
    # We can filter on this nested index and say "get me the last 10 results" or something
    predictionSets: [PredictionSet] @hasMany(indexName: "byUser" fields: ["id"])
}

type Relationship @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    followedUserId: ID! @index(queryField: "relationshipByFollowedUserId")
    followedUser: User! @hasOne(fields: ["followedUserId"])
    followingUserId: ID! @index(queryField: "relationshipByFollowingUserId")
    followingUser: User! @hasOne(fields: ["followingUserId"])
}

type Event @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    categories: [Category] @hasMany(indexName: "byEvent", fields: ["id"])
    awardsBody: AwardsBody!
    year: Int!
    nominationDateTime: AWSDateTime # nullable. admin sets this
    winDateTime: AWSDateTime # nullable. admin sets this
    status: EventStatus @default(value: "NOMS_STAGING")
    # COULD make a hasMany on CommunityPredictionSet here, for ex to display some contenders from the events page
    predictions: [CommunityPredictionSet] @hasMany(indexName: "byEvent", fields: ["id"])
}

type Category @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    eventId: ID! @index(name: "byEvent", queryField: "categoryByEvent")
    event: Event! @belongsTo(fields: ["eventId"])
    name: CategoryName!
    type: CategoryType! @default(value: "FILM")
    isShortlisted: CategoryIsShortlisted @default(value: "FALSE")
}

# Belongs to a particular category
type Contender @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    eventId: ID!
    event: Event! @hasOne(fields: ["eventId"])
    movieId: ID! @index(name: "byMovie", queryField: "contenderByMovie")
    movie: Movie! @belongsTo(fields: ["movieId"]) # lets it be bi-directional so we can see Contenders from Movie
    personId: ID
    person: Person @hasOne(fields: ["personId"]) # optional - only applies to acting categories
    songId: ID
    song: Song @hasOne(fields: ["songId"]) # optional - only applies to the song category
    visibility: ContenderVisibility
    accolade: ContenderAccolade # nullable
}

type Movie @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    contenders: [Contender] @hasMany(indexName: "byMovie", fields: ["id"])
    tmdbId: Int! # unique value
    studio: String # distribution studio
}

type Person @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    tmdbId: Int! # unique value
}
  
type Song @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    movieId: ID!
    movie: Movie! @hasOne(fields: ["movieId"])
    title: String!
    artist: String!
}

# PREDICTIONS:

# CURRENT PERSONAL
type PredictionSet @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    # we need predictionSetByUserIdAndEventId to make a request for all user's predictions in a given category
    # what about for a social feed? We might want to know what the last 10 categories they updated were, and get it from all followers, which is DEFINITELY based on createdAt. So I'm gonna say, second index
    # DO WE WANT CREATED_AT?? Because we might ONLY want to query for this if they've made predictions in the last month. We don't want to return ALL their predictions that's insane. At that point, it's just a separate query, predictionSetByUserIdAndEventId
    userId: ID! 
        @index(sortKeyFields: ["eventId"], queryField: "predictionSetByUserIdAndEventId") # used for request on a single user's predictions in given event
        @index(name: "byUser", sortKeyFields: ["createdAt"], queryField: "predictionSetByUserIdAndCreatedAt") # need to use createdAt as sort key in order to return in order. Then in practice, put a limit on the results
    user: User! @hasOne(fields: ["userId"])
    eventId: ID! @index(queryField: "predictionSetByEventId") # used for compiling community predictions
    event: Event! @hasOne(fields: ["eventId"])
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    predictions: [Prediction] @hasMany(indexName: "byPredictionSet", fields: ["id"])
    type: PredictionType @default(value: "NOMINATION")
    comment: String
    createdAt: AWSDateTime!
}
type Prediction @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    predictionSetId: ID! @index(name: "byPredictionSet", queryField: "predictionByPredictionSetId")
    contenderId: ID!
    contender: Contender! @hasOne(fields: ["contenderId"])
    ranking: Int!
}

# HISTORY PERSONAL
type HistoryPredictionSet @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    userId: ID! @index(sortKeyFields: ["eventId", "createdAt"], queryField: "historyPredictionSetByUserIdAndEventIdAndCreatedAt")
    user: User! @hasOne(fields: ["userId"])
    eventId: ID!
    event: Event! @hasOne(fields: ["eventId"])
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    predictions: [HistoryPrediction] @hasMany(indexName: "byHistoryPredictionSet", fields: ["id"])
    type: PredictionType @default(value: "NOMINATION")
    createdAt: AWSDateTime!
}
type HistoryPrediction @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    historyPredictionSetId: ID! @index(name: "byHistoryPredictionSet", queryField: "historyPredictionByHistoryPredictionSetId")
    contenderId: ID!
    contender: Contender! @hasOne(fields: ["contenderId"])
    ranking: Int!
}

# CURRENT COMMUINTY
type CommunityPredictionSet @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    eventId: ID! 
        @index(queryField: "communityPredictionSetByEventId")
        @index(name: "byEvent", queryField: "communityPredictionSetByEventId")
    event: Event! @hasOne(fields: ["eventId"])
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    predictions: [CommunityPrediction] @hasMany(indexName: "byCommunityPredictionSet", fields: ["id"])
    type: PredictionType @default(value: "NOMINATION")
}
type CommunityPrediction @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    communityPredictionSetId: ID! @index(name: "byCommunityPredictionSet", queryField: "communityPredictionByCommunityPredictionSetId")
    contenderId: ID!
    contender: Contender! @hasOne(fields: ["contenderId"])
    ranking: Int!
    indexedRankings: String # JSON stringified array of rankings (ts: { [place: number]: [numUsersPredicting: number]})
}

# HISTORY COMMUINTY
type CommunityHistoryPredictionSet @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    eventId: ID! @index(sortKeyFields: ["createdAt"], queryField: "communityHistoryPredictionSetsByEventIdAndCreatedAt")
    event: Event! @hasOne(fields: ["eventId"])
    categoryId: ID!
    category: Category! @hasOne(fields: ["categoryId"])
    predictions: [CommunityHistoryPrediction] @hasMany(indexName: "byCommunityHistoryPredictionSet", fields: ["id"])
    type: PredictionType @default(value: "NOMINATION")
    createdAt: AWSDateTime!
}
type CommunityHistoryPrediction @model @auth(rules: [{ allow: public }]) {
    id: ID! @primaryKey
    communityHistoryPredictionSetId: ID! @index(name: "byCommunityHistoryPredictionSet", queryField: "communityHistoryPredictionByCommunityHistoryPredictionSetId")
    contenderId: ID!
    contender: Contender! @hasOne(fields: ["contenderId"])
    categoryId: ID! @index(queryField: "communityHistoryPredictionByCategoryId") # for getting the category history chart
    category: Category! @hasOne(fields: ["categoryId"])
    ranking: Int!
    indexedRankings: String # JSON stringified array of rankings (ts: { [place: number]: [numUsersPredicting: number]})
}

# CONNECT LAMBDA FUNCTIONS (Configures function for AppSync)
# https://docs.amplify.aws/cli/graphql/custom-business-logic/#how-it-works
type Mutation {
  updateCommunityPredictions(msg: String): String @function(name: "updateCommunityPredictions-${env}")
  updatePersonalHistory(msg: String): String @function(name: "updatePersonalHistory-${env}")
}